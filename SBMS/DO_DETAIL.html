<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<title></title>
		<style type="text/css">
			/* Modal container */
			.modal {
			    display: none; /* Hidden by default */
			    position: fixed; /* Stay in place */
			    z-index: 1; /* Sit on top */
			    left: 0;
			    top: 0;
			    width: 100%; /* Full width */
			    height: 100%; /* Full height */
			    overflow: auto; /* Enable scroll if needed */
			    background-color: rgb(0,0,0); /* Fallback color */
			    background-color: rgba(0,0,0,0.4); /* Black w/ opacity */
			    padding-top: 60px; /* Padding from the top */
			}

			/* Modal content */
			.modal-content {
			    background-color: #fefefe;
			    margin: 5% auto; /* 5% from the top and centered */
			    padding: 20px;
			    border: 1px solid #888;
			    width: 80%; /* Could be more or less, depending on screen size */
			    max-width: 900px; /* Maximum width for larger screens */
			    border-radius: 10px; /* Rounded corners */
			    box-shadow: 0 5px 15px rgba(0,0,0,0.3); /* Subtle shadow for depth */
			}

			/* Close button */
			.close {
			    position: absolute;
			    right: 25px;
			    top: 20px;
			    color: #aaa;
			    font-size: 28px;
			    font-weight: bold;
			    cursor: pointer;
			}

			.close:hover,
			.close:focus {
			    color: #000;
			    text-decoration: none;
			    cursor: pointer;
			}

			/* Table styling inside modal */
			#scannedTable {
			    width: 100%;
			    border-collapse: collapse;
			    margin-top: 20px;
			}

			#scannedTable th, #scannedTable td {
			    border: 1px solid #ddd;
			    padding: 8px;
			}

			#scannedTable th {
			    background-color: #f2f2f2;
			    text-align: left;
			}

			#scannedTable td {
			    text-align: center;
			}

			/* Progress bar */
			.progress {
			    margin-top: 20px;
			}

			progress {
			    width: 100%;
			    height: 20px;
			}

			/* Responsive video feed for camera scanning (mobile) */
            #cameraFeed {
                width: 100%;
                height: auto; /*240px;*/
                object-fit: cover;
                border: 2px solid #333; /*1px solid #ddd;*/
                border-radius: 5px;
                margin-top: 10px;
            }

            #cameraContainer {
		      position: relative;
		      width: 320px; /* Adjust as needed */
		      margin: auto;
		    }
		    #cameraFeed {
		      width: 100%;
		      height: auto;
		    }
		    #overlayCanvas {
		      position: absolute;
		      top: 0;
		      left: 0;
		      width: 100%;
		      height: 100%;
		      pointer-events: none; /* Allows clicks to pass through */
		    }
		    .rectangle {
		      border: 2px solid red;
		      position: absolute;
		      top: 20%;
		      left: 10%;
		      width: 80%;
		      height: 60%;
		    }
		    #controls {
		      text-align: center;
		      margin-top: 10px;
		    }

		    .toast {
			    position: fixed;
			    bottom: 20px;
			    left: 50%;
			    transform: translateX(-50%);
			    background-color: #333;
			    color: #fff;
			    padding: 10px 20px;
			    border-radius: 5px;
			    z-index: 1000; /* Ensure it appears on top */
			    font-size: 16px;
			    display: none;
			}

			.toast.show {
			    display: block;
			    animation: fadeIn 0.5s, fadeOut 0.5s 2.5s;
			}

			@keyframes fadeIn {
			    from { opacity: 0; }
			    to { opacity: 1; }
			}

			@keyframes fadeOut {
			    from { opacity: 1; }
			    to { opacity: 0; }
			}
			
		</style>
		<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css" crossorigin="anonymous" />
	    <script src="tpac_library/js/jsQR.js"></script>
	    <meta name="viewport" content="width=device-width, initial-scale=1.0">
	    <link rel="stylesheet" href="tpac_library/css/dataTables.min.css">
	    <link rel="stylesheet" type="text/css" href="tpac_library/css/dataTables.buttons.min.css">
	    <link rel="stylesheet" type="text/css" href="tpac_library/css/responsive.dataTables.min.css">
	    <!-- <script id="TeamsJs" src="tpac_library/js/MicrosoftTeams.min.js" async></script> -->
	    <script src="tpac_library/js/pdfmake.min.js" async></script>
	    <script src="tpac_library/js/jquery-3.7.1.slim.min.js"></script>
	    <script src="tpac_library/js/dataTables.min.js"></script>
	    <script src="tpac_library/js/dataTables.responsive.min.js"></script>
	    <script src="tpac_library/js/dataTables.buttons.min.js"></script>


	</head>
	<body>
		<h1 id="detailsHeader"></h1>
		<h3 id="detailsSummary"></h3>

		<div id="itemDetailsModal" class="modal">
		    <div class="modal-content" id="modalContent">
		       
		        <!-- Dynamic content will be injected here by JavaScript -->
		        <div id="itemDetailsContent" style="display: none;">
		            <!-- Item details will be displayed here -->

		        </div>
		    </div>
		    <span class="close" id="closeModal">&times; CLOSE</span>
		</div>


		<table id="ordersTable">
		    <thead>
		        <tr>
		            <th>ITEM CODE</th>
		            <th>ITEM NAME</th>
		            <th>PACKING SIZE</th>
		            <th>LOCATION</th>
		            <th>SCHEDULED QTY</th>
		            <th>DISPATCHED QTY</th>
		            <th>PENDING QTY</th>
		        </tr>
		    </thead>
		    <tbody>
		        <!-- Rows will be added dynamically by JavaScript -->
		    </tbody>
		</table>

		<script type="text/javascript">
			
			// let api_base_url = 'http://192.168.12.14:3000/sbms';
			// let api_base_url = 'https://192.168.12.18:3001/sbms';
        	let api_base_url = 'https://api.tpacpackaging.com:3001/sbms';
	        // let detail_page_url = 'http://192.168.12.14:8888/DO_DETAIL.html';
	        let detail_page_url = 'https://aywm.github.io/PowerPlatform/SBMS/DO_DETAIL.html';
			let scannedCartons = [];
			let cameraAvailable,scanner;

			// Define an async function to handle camera availability and fetch order details
			async function handlePageLoad() {
			    const urlParams = new URLSearchParams(window.location.search);
			    const doNumber = urlParams.get('doNumber');
			    const unit_id = urlParams.get('unit_id');
			    const deliveryOrderId = urlParams.get('deliveryOrderId');
			    
			    try {
			        // Get the device info, whether camera is available or not
			        cameraAvailable = await hasCamera();

			        // Update the UI or handle camera availability
			        console.log('Camera available:', cameraAvailable); // Or use it as needed

			        document.getElementById('detailsHeader').innerText = `Showing Details for Delivery Order Number: ${doNumber}`;
			        fetchOrderDetails(unit_id, deliveryOrderId);
			    } catch (error) {
			        console.error('Error during page load:', error);
			    }
			}

			// Call the async function when the DOM content is fully loaded
			document.addEventListener('DOMContentLoaded', function () {
			    handlePageLoad();
			});

			// Close the modal when the user clicks on <span> (x)
			document.getElementById('closeModal').onclick = function() {
			    closeModal();
			}

			// Close the modal when the user clicks anywhere outside of the modal
			window.onclick = function(event) {
			    const modal = document.getElementById('itemDetailsModal');
			    if (event.target === modal) {
			        closeModal();
			    }
			}

			// Move this function outside of the CameraScanner class
            function debounce(func, wait) {
                let timeout;
                return function (...args) {
                    clearTimeout(timeout);
                    timeout = setTimeout(() => func.apply(this, args), wait);
                };
            }

			// class ScannerMan {
            //     constructor(isCameraAvailable) {
			// 		this.videoElement = null;
			// 		this.stream = null;
			// 		this.canvasElement = null;
			// 		this.ctx = null;
			// 		this.overlayCanvas = null;
			// 		this.overlayCtx = null;
			// 		this.scanIntervalId = null;
			// 		this.callback = null;
			// 		this.handlePlay = this.handlePlay.bind(this);
			// 		this.handlePause = this.handlePause.bind(this); 
			// 		this.alertTimeout = null;
			// 		this.audioContext = null;
			// 		this.errorBeepSound = null;
			// 		this.correctBeepSound = null;
			// 		this.isCameraAvailable = isCameraAvailable;
        	// 		this.scanDelay = 369; // Time interval to prevent double scans
        	// 		this.lastScanTime = 0; // Initialize in the constructor

		    //         // Accessing video element to display camera feed
		    //         this.videoElement = document.getElementById('cameraFeed');
		    //         this.overlayCanvas = document.getElementById('overlayCanvas');
        	// 		this.isScanning = true;

        	// 		try{
			//             // Initialize error beep sound
			//             this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
			//             this.errorBeepSound = new Audio('tpac_library/audio/beep-05.mp3');
	        //             this.correctBeepSound = new Audio('tpac_library/audio/beep-02.mp3');
			// 	    }catch(error) {
	        //             console.error("Error loading beep sound:", error);
	        //         }

        	// 		//Set up event listeners
            //         this.setupEventListeners();
            //     }

            //     showAlert(message) {
			// 	    clearTimeout(this.alertTimeout);
			// 	    this.alertTimeout = setTimeout(() => {
			// 	        alert(message);
			// 	    }, 500); // Wait half a second before showing the alert
			// 	}

			// 	async startScanning(callback) {
			//         try {
			//             this.callback = callback;

			//             if (this.isCameraAvailable) {
			// 	            if (!this.videoElement) throw new Error('Video element not found.');
			// 	            if (!this.overlayCanvas) throw new Error('Overlay canvas element not found.');

			// 	            this.stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } });
			// 	            this.stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } })
			// 								    .catch(error => {
			// 								        console.error('Error accessing the camera:', error);
			// 								        alert('Camera access denied. Please allow camera access and click Retry.');
			// 								        return null;
			// 								    });
			// 				if (!this.stream) return; // Exit if stream couldn't start
			// 	            this.videoElement.srcObject = this.stream;

			// 	            // Ensure video plays as soon as the metadata is loaded
			// 	            this.videoElement.onloadedmetadata = () => {
			// 	                this.videoElement.play();
			// 	                this.handlePlay(); // Start scanning once video is ready
			// 	            };

			// 	            // Create a canvas to capture frames from the video feed
			// 	            this.canvasElement = document.createElement('canvas');
			// 	            this.ctx = this.canvasElement.getContext('2d', { willReadFrequently: true });
			// 	            if (!this.ctx) throw new Error('Canvas 2D context not found.');

			// 	            // Create overlay canvas for the fixed rectangle
			// 	            this.overlayCtx = this.overlayCanvas.getContext('2d', { willReadFrequently: true });
			// 	        }

			//             return new Promise(resolve => resolve());
			//         } catch (error) {
			//             console.error("Error starting camera scan:", error);
			//             alert('Camera access denied. Please allow camera access and click Retry.');
			//         }
			//     }

			//     handleScannedData(scanData) {
			//     	try{
			// 		    let response = this.callback(scanData);
			// 		    if (response.includes("Error:")) {
			// 		        if (this.errorBeepSound) this.errorBeepSound.play();
			// 		        this.showAlert(response);
			// 		    } else {
			// 		        if (this.correctBeepSound) this.correctBeepSound.play();
			// 		    }
			// 		    return response;
			// 		catch(error){
			// 			console.error("Error inside handleScannedData:", error);
			// 			return '0';
			// 		}
			// 	}


            //     setupEventListeners() {

      		// 		console.log('About to setup listereners with Camera Available: ' + this.isCameraAvailable);

            //     	if (this.isCameraAvailable) {

	        //         	this.videoElement.addEventListener('play', this.handlePlay);
	        //             this.videoElement.addEventListener('pause', this.handlePause);

			// 	        document.getElementById('toggleScan').addEventListener('click', () => {
			// 			if (this.isScanning) {
			// 				this.handlePause();
			// 				document.getElementById('toggleScan').textContent = 'Resume';
			// 			} else {
			// 				this.handlePlay();
			// 				document.getElementById('toggleScan').textContent = 'Pause';
			// 			}
			// 				this.isScanning = !this.isScanning;	
			// 			});

			// 		}else{
			// 			const scannerInput = document.getElementById('scannerInput');
			// 			if (scannerInput) {
			// 	            scannerInput.addEventListener('keypress', e => {
			// 	                if (e.key === 'Enter') {
			// 	                    let scanData = e.target.value.trim();
			// 	                    this.handleScannedData(scanData);
			// 	                    e.target.value = ''; // Clear input
			// 	                }
			// 	            });
			// 	        } else {
			// 	            console.error('Scanner input field is not available.');
			// 	        }
			// 		}
			//     }

            //     handlePlay() {
            //         // Update canvas dimensions when video starts playing
            //         this.updateCanvasDimensions();
            //         this.drawFixedRectangle();
            //         if (this.callback) {
        	// 			console.log('Video element playing:', !this.videoElement.paused);
            //             this.CameraScanHandler(this.callback); // Ensure callback is passed
            //         }
            //     }

            //     handlePause() {
            //         // Stop scanning when video pauses
            //         this.stopScanning();
            //     }

            //     updateCanvasDimensions() {
            //         if (this.canvasElement && this.videoElement) {
            //             this.canvasElement.width = this.videoElement.videoWidth;
            //             this.canvasElement.height = this.videoElement.videoHeight;
            //             this.overlayCanvas.width = this.videoElement.videoWidth;
            //             this.overlayCanvas.height = this.videoElement.videoHeight;
            //             console.log('Canvas dimensions:', this.canvasElement.width, this.canvasElement.height);
   
            //         } else {
            //             console.error('Canvas or video element not properly initialized.');
            //         }
            //     }

			// 	drawFixedRectangle() {
			// 		if (this.overlayCtx) {
			// 			const width = this.overlayCanvas.width;
			// 			const height = this.overlayCanvas.height;

			// 			this.overlayCtx.clearRect(0, 0, width, height);
			// 			this.overlayCtx.strokeStyle = 'red'; //'rgba(255, 0, 0, 0.5)'
			// 			this.overlayCtx.lineWidth = 2;
			// 			// this.overlayCtx.strokeRect(50, 50, this.canvasElement.width - 100, this.canvasElement.height - 100);
			// 			this.overlayCtx.strokeRect(width * 0.1, height * 0.2, width * 0.8, height * 0.6);
			// 		} else {
            //             console.error('Overlay canvas context not found.');
            //         }
			// 	}

            //     drawLine(begin, end, color) {
            //         this.ctx.beginPath();
            //         this.ctx.moveTo(begin.x, begin.y);
            //         this.ctx.lineTo(end.x, end.y);
            //         this.ctx.lineWidth = 4;
            //         this.ctx.strokeStyle = color;
            //         this.ctx.stroke();
            //     }

            //     // Method to draw a box around the QR code
            //     drawBoxAroundQRCode(location) {
            //         this.drawLine(location.topLeftCorner, location.topRightCorner, "#FF3B58");
            //         this.drawLine(location.topRightCorner, location.bottomRightCorner, "#FF3B58");
            //         this.drawLine(location.bottomRightCorner, location.bottomLeftCorner, "#FF3B58");
            //         this.drawLine(location.bottomLeftCorner, location.topLeftCorner, "#FF3B58");
            //     }



            //     CameraScanHandler(callback) {

            //     	if (!callback) {
            //             this.showAlert('Callback function is not provided.');
            //             return;
            //         }

            //         const scan = () => {
        				
        	// 			console.log('RequestAnimationFrame is running');

        	// 			// Add a flag to check if scanning should continue
			// 	        if (!this.isScanning) {
			// 	            return;
			// 	        }
			            
			//             const now = Date.now();
			//             if (now - this.lastScanTime < this.scanDelay) {
			//                 requestAnimationFrame(scan);
			//                 return;
			//             }

			//             this.overlayCtx.clearRect(0, 0, this.overlayCanvas.width, this.overlayCanvas.height);
			//             this.drawFixedRectangle();

			//             this.ctx.drawImage(this.videoElement, 0, 0, this.canvasElement.width, this.canvasElement.height);


			// 	        const cropX = this.overlayCanvas.width * 0.1;
			// 			const cropY = this.overlayCanvas.height * 0.2;
			// 			const cropWidth = this.overlayCanvas.width * 0.8;
			// 			const cropHeight = this.overlayCanvas.height * 0.6;

			// 			const imageData = this.ctx.getImageData(cropX, cropY, cropWidth, cropHeight);

			// 	        // Detect QR code
			// 	        const qrCode = jsQR(imageData.data, cropWidth, cropHeight, { inversionAttempts: "dontInvert" });

		    //             if (qrCode) {
		    //             	if (now - this.lastScanTime >= this.scanDelay) {
		    //             		console.log('QR DATA:' + qrCode.data);
			// 	                this.lastScanTime = now;  // Update last scan time

			// 	                const response = this.handleScannedData(qrCode.data);
			// 	                requestAnimationFrame(scan);  // Only continue scanning if no error
			// 	            }
		    //             } else {
			// 	            requestAnimationFrame(scan);  // Continue scanning if no QR code detected
			// 	        }
		    //     	};

			//         requestAnimationFrame(scan);
			//     }

            //     stopScanning() {
            //         clearInterval(this.scanIntervalId);
            //         this.scanIntervalId = null;
            //         if (this.stream) {
            //         	// Stop the video stream
            //             this.stream.getTracks().forEach(track => track.stop());
			//         }
			//         // Remove video element from the DOM
            //         this.videoElement.pause();
            //         this.videoElement.srcObject = null;
            //         this.videoElement.remove();

            //         // Clean up event listeners
            //         this.videoElement.removeEventListener('play', this.handlePlay);
            //         this.videoElement.removeEventListener('pause', this.handlePause);

            //         // Remove other resources
            //         this.canvasElement.remove();
            //     }

            //     async stopCameraScan() {
            //         try {

            //         	if (this.isScanning) {
			// 		        this.isScanning = false;
			// 		        this.stopScanning();
			// 		    }

            //             console.log("Camera scan stopped successfully");
            //         } catch (error) {
            //             console.error("Error stopping camera scan:", error);
            //         }
            //     }

            // }

            class ScannerMan {
			    constructor(isCameraAvailable) {
			        this.videoElement = null;
			        this.stream = null;
			        this.canvasElement = null;
			        this.ctx = null;
			        this.overlayCanvas = null;
			        this.overlayCtx = null;
			        this.scanIntervalId = null;
			        this.callback = null;
			        this.handlePlay = this.handlePlay.bind(this);
			        this.handlePause = this.handlePause.bind(this);
			        this.alertTimeout = null;
			        this.audioContext = null;
			        this.errorBeepSound = null;
			        this.correctBeepSound = null;
			        this.isCameraAvailable = isCameraAvailable;
			        this.scanDelay = 369; // Time interval to prevent double scans
			        this.lastScanTime = 0; // Initialize in the constructor

			        // Accessing video element to display camera feed
			        this.videoElement = document.getElementById('cameraFeed');
			        this.overlayCanvas = document.getElementById('overlayCanvas');
			        this.isScanning = true;

			        try {
			            // Initialize error beep sound
			            this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
			            this.errorBeepSound = new Audio('tpac_library/audio/beep-05.mp3');
			            this.correctBeepSound = new Audio('tpac_library/audio/beep-02.mp3');
			        } catch (error) {
			            console.error("Error loading beep sound:", error);
			        }

			        // Set up event listeners
			        this.setupEventListeners();
			    }

			    showAlert(message) {
			        clearTimeout(this.alertTimeout);
			        this.alertTimeout = setTimeout(() => {
			            // Use a more subtle UI element instead of alert
			            console.warn(message);
			        }, 500); // Wait half a second before showing the alert
			    }

			    // Function to show the toast message
				showToast(message) {
				    const toast = document.createElement('div');
				    toast.className = 'toast show';
				    toast.textContent = message;
				    document.body.appendChild(toast);

				    // Hide the toast after a few seconds
				    setTimeout(() => {
				        toast.classList.remove('show');
				        toast.classList.add('hide');
				        // Remove the toast from the DOM after hiding
				        toast.addEventListener('transitionend', () => {
				            toast.remove();
				        });
				    }, 3000); // Adjust duration as needed
				}


			    async startScanning(callback) {
			        try {
			            this.callback = callback;

			            if (this.isCameraAvailable) {
			                if (!this.videoElement) throw new Error('Video element not found.');
			                if (!this.overlayCanvas) throw new Error('Overlay canvas element not found.');

			                this.stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } });
			                if (!this.stream) return; // Exit if stream couldn't start
			                this.videoElement.srcObject = this.stream;

			                // Ensure video plays as soon as the metadata is loaded
			                this.videoElement.onloadedmetadata = () => {
			                    this.videoElement.play();
			                    this.handlePlay(); // Start scanning once video is ready
			                };

			                // Create a canvas to capture frames from the video feed
			                this.canvasElement = document.createElement('canvas');
			                this.ctx = this.canvasElement.getContext('2d', { willReadFrequently: true });
			                if (!this.ctx) throw new Error('Canvas 2D context not found.');

			                // Create overlay canvas for the fixed rectangle
			                this.overlayCtx = this.overlayCanvas.getContext('2d', { willReadFrequently: true });
			            }

			            return new Promise(resolve => resolve());
			        } catch (error) {
			            console.error("Error starting camera scan:", error);
			            this.showToast("Error starting camera scan: " + error.message + ", click Retry");
			        }
			    }

			    handleScannedData(scanData) {
			        try {
			            let response = this.callback(scanData);
			            if (response.includes("Error:")) {
			                if (this.errorBeepSound) this.errorBeepSound.play();
			                // this.showAlert(response);
			            	this.showToast(response); // Show toast message
			            } else {
			                if (this.correctBeepSound) this.correctBeepSound.play();
			            }
			            return response;
			        } catch (error) {
			            console.error("Error inside handleScannedData:", error);
			            this.showToast("Error inside handleScannedData:"+error.message);
			            return '0';
			        }
			    }

			    setupEventListeners() {
			        console.log('About to setup listeners with Camera Available: ' + this.isCameraAvailable);

			        if (this.isCameraAvailable) {
			            this.videoElement.addEventListener('play', this.handlePlay);
			            this.videoElement.addEventListener('pause', this.handlePause);

			            document.getElementById('toggleScan').addEventListener('click', () => {
			                if (this.isScanning) {
			                    this.handlePause();
			                    document.getElementById('toggleScan').textContent = 'Resume';
			                } else {
			                    this.handlePlay();
			                    document.getElementById('toggleScan').textContent = 'Pause';
			                }
			                this.isScanning = !this.isScanning;
			            });
			        } else {
			            const scannerInput = document.getElementById('scannerInput');
			            if (scannerInput) {
			                scannerInput.addEventListener('keypress', e => {
			                    if (e.key === 'Enter') {
			                        let scanData = e.target.value.trim();
			                        this.handleScannedData(scanData);
			                        e.target.value = ''; // Clear input
			                    }
			                });
			            } else {
			                console.error('Scanner input field is not available.');
			                this.showToast('Scanner input field is not available.');
			            }
			        }
			    }

			    handlePlay() {
			        // Update canvas dimensions when video starts playing
			        this.updateCanvasDimensions();
			        this.drawFixedRectangle();
			        if (this.callback) {
			            console.log('Video element playing:', !this.videoElement.paused);
			            this.CameraScanHandler(this.callback); // Ensure callback is passed
			        }
			    }

			    handlePause() {
			        // Stop scanning when video pauses
			        this.stopScanning();
			    }

			    updateCanvasDimensions() {
			        if (this.canvasElement && this.videoElement) {
			            this.canvasElement.width = this.videoElement.videoWidth;
			            this.canvasElement.height = this.videoElement.videoHeight;
			            this.overlayCanvas.width = this.videoElement.videoWidth;
			            this.overlayCanvas.height = this.videoElement.videoHeight;
			            console.log('Canvas dimensions:', this.canvasElement.width, this.canvasElement.height);
			        } else {
			            console.error('Canvas or video element not properly initialized.');
			            this.showToast('Canvas or video element not properly initialized.');
			        }
			    }

			    drawFixedRectangle() {
			        if (this.overlayCtx) {
			            const width = this.overlayCanvas.width;
			            const height = this.overlayCanvas.height;

			            this.overlayCtx.clearRect(0, 0, width, height);
			            this.overlayCtx.strokeStyle = 'red'; //'rgba(255, 0, 0, 0.5)'
			            this.overlayCtx.lineWidth = 2;
			            this.overlayCtx.strokeRect(width * 0.1, height * 0.2, width * 0.8, height * 0.6);
			        } else {
			            console.error('Overlay canvas context not found.');
			            this.showToast("Overlay canvas context not found.");
			        }
			    }

			    drawLine(begin, end, color) {
			        this.ctx.beginPath();
			        this.ctx.moveTo(begin.x, begin.y);
			        this.ctx.lineTo(end.x, end.y);
			        this.ctx.lineWidth = 4;
			        this.ctx.strokeStyle = color;
			        this.ctx.stroke();
			    }

			    drawBoxAroundQRCode(location) {
			        this.drawLine(location.topLeftCorner, location.topRightCorner, "#FF3B58");
			        this.drawLine(location.topRightCorner, location.bottomRightCorner, "#FF3B58");
			        this.drawLine(location.bottomRightCorner, location.bottomLeftCorner, "#FF3B58");
			        this.drawLine(location.bottomLeftCorner, location.topLeftCorner, "#FF3B58");
			    }

			    CameraScanHandler(callback) {
			        if (!callback) {
			            this.showAlert('Callback function is not provided.');
			            return;
			        }

			        const scan = () => {
			            console.log('RequestAnimationFrame is running');

			            // Add a flag to check if scanning should continue
			            if (!this.isScanning) {
			                return;
			            }

			            const now = Date.now();
			            if (now - this.lastScanTime < this.scanDelay) {
			                requestAnimationFrame(scan);
			                return;
			            }

			            this.overlayCtx.clearRect(0, 0, this.overlayCanvas.width, this.overlayCanvas.height);
			            this.drawFixedRectangle();

			            this.ctx.drawImage(this.videoElement, 0, 0, this.canvasElement.width, this.canvasElement.height);

			            const cropX = this.overlayCanvas.width * 0.1;
			            const cropY = this.overlayCanvas.height * 0.2;
			            const cropWidth = this.overlayCanvas.width * 0.8;
			            const cropHeight = this.overlayCanvas.height * 0.6;

			            const imageData = this.ctx.getImageData(cropX, cropY, cropWidth, cropHeight);

			            // Detect QR code
			            const qrCode = jsQR(imageData.data, cropWidth, cropHeight, { inversionAttempts: "dontInvert" });

			            if (qrCode) {
			                if (now - this.lastScanTime >= this.scanDelay) {
			                    console.log('QR DATA:' + qrCode.data);
			                    this.lastScanTime = now;  // Update last scan time

			                    const response = this.handleScannedData(qrCode.data);
			                    requestAnimationFrame(scan);  // Only continue scanning if no error
			                }
			            } else {
			                requestAnimationFrame(scan);  // Continue scanning if no QR code detected
			            }
			        };

			        requestAnimationFrame(scan);
			    }

			    stopScanning() {
			        clearInterval(this.scanIntervalId);
			        this.scanIntervalId = null;
			        if (this.stream) {
			            // Stop the video stream
			            this.stream.getTracks().forEach(track => track.stop());
			        }
			        // Remove video element from the DOM
			        this.videoElement.pause();
			        this.videoElement.srcObject = null;
			        this.videoElement.remove();

			        // Clean up event listeners
			        this.videoElement.removeEventListener('play', this.handlePlay);
			        this.videoElement.removeEventListener('pause', this.handlePause);

			        // Remove other resources
			        this.canvasElement.remove();
			    }

			    async stopCameraScan() {
			        try {
			            if (this.isScanning) {
			                this.isScanning = false;
			                this.stopScanning();
			            }

			            console.log("Camera scan stopped successfully");
			            this.showToast("Camera scan stopped successfully");
			        } catch (error) {
			            console.error("Error stopping camera scan:", error);
			            this.showToast("Error stopping camera scan: "+error.message);
			        }
			    }
			}



            async function fetchOrderDetails(p_unit_id,p_deliveryOrderId) {
                try {
                    const email_id = '';
                    const username = '';
                    const password = '';
                    const unit_id = p_unit_id;
                    const data_type = 'PENDING_DO';
                    const search_param = p_deliveryOrderId;
                    const response = await fetch(`${api_base_url}/SelectFromSBMS`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({username, password, unit_id, email_id, data_type, search_param})
                    });
                    const data = await response.json();
                    displayOrderDetails(data.output);
                } catch (error) {
                    console.error('Error fetching pending orders:', error);
                }
            }


			function displayOrderDetails(orders) {
			    const tableBody = document.getElementById('ordersTable').querySelector('tbody');
			    tableBody.innerHTML = ''; // Clear any existing rows

			    let totalItems = 0;
			    let totalScheduledQty = 0;
			    let totalDispatchedQty = 0;
			    let totalPendingQty = 0;
			    

			    orders.forEach(detail => {
			        const row = document.createElement('tr');
			        console.log(detail);
			        // Update the totals
			        totalItems += 1;
			        totalScheduledQty += detail.SCHEDULED_QTY;
			        totalDispatchedQty += detail.DISPATCHED_QTY;
			        totalPendingQty += detail.PENDING_QTY;

			        // Creating table cells
			        row.innerHTML = `
			            <td data-label="ITEM CODE">
			                <a href="#" onclick="showItemDetails('${detail.ITEM_CODE}','${detail.ITEM_ID}',${detail.PENDING_QTY},${detail.PACKING_SIZE})">
			                    <i class="fas fa-info-circle"></i> ${detail.ITEM_CODE}
			                </a>
			            </td>
			            <td data-label="ITEM NAME">${detail.ITEM_NAME}</td>
			            <td data-label="PACKING SIZE">${detail.PACKING_SIZE}</td>
			            <td data-label="LOCATION">${detail.LOCATION}</td>
			            <td data-label="SCHEDULED QTY">
			                ${detail.SCHEDULED_QTY.toLocaleString(undefined, {
			                    minimumFractionDigits: 2,
			                    maximumFractionDigits: 7
			                })}
			            </td>
			            <td data-label="DISPATCHED QTY">
			                ${detail.DISPATCHED_QTY.toLocaleString(undefined, {
			                    minimumFractionDigits: 2,
			                    maximumFractionDigits: 7
			                })}
			            </td>
			            <td data-label="PENDING QTY">
			                ${detail.PENDING_QTY.toLocaleString(undefined, {
			                    minimumFractionDigits: 2,
			                    maximumFractionDigits: 7
			                })}
			            </td>
			        `;
			        tableBody.appendChild(row);
			    });

			    // Display the totals
			    let text_summary = '';
			    text_summary =`Total Items: ${totalItems}`;
			    text_summary = text_summary + ', Total Scheduled: ' + totalScheduledQty.toLocaleString(undefined, {
			        minimumFractionDigits: 2,
			        maximumFractionDigits: 7
			    });
			    text_summary = text_summary + ', Total Dispatched: ' + totalDispatchedQty.toLocaleString(undefined, {
			        minimumFractionDigits: 2,
			        maximumFractionDigits: 7
			    });
			    text_summary = text_summary + ', Total Pending: ' + totalPendingQty.toLocaleString(undefined, {
			        minimumFractionDigits: 2,
			        maximumFractionDigits: 7
			    });

			    document.getElementById('detailsSummary').textContent = text_summary;

			    new DataTable('#ordersTable'
                        ,{
                            responsive: true,
                            buttons: [  'copy', 'csv',  'excel', 'print'
                                        ,{
                                            extend: 'pdfHtml5',
                                            orientation: 'landscape',
                                            // pageSize: search_param === 'ALL' ? 'A2' : 'A4'
                                        }
                                    ],
                            layout: {
                                top2Start: 'buttons'
                            },
                            fixedColumns: {
							    leftColumns: [0, 1]
							},
                            "searching": true,
                            "ordering": true,
                            "info": true,
                            "lengthChange": true,
                            "lengthMenu": [[25, 50, 75, -1], [25, 50, 75, "All"]],
                            "striped": true,
                            "hover": true
                        }
                );
			}

			// Function to save data in JSON or CSV format
			function saveData(format) {

			    dataToSave = getScannedData();

			    if (format === 'json') {
			        const blob = new Blob([JSON.stringify(dataToSave)], { type: 'application/json' });
			        saveFile(blob, 'scanned_data.json');
			    } else if (format === 'csv') {
			        const csvData = convertToCSV(dataToSave);
			        const blob = new Blob([csvData], { type: 'text/csv' });
			        saveFile(blob, 'scanned_data.csv');
			    }
			    
			    pushToSBMS(dataToSave);
			}

			// Function to push data to SBMS
			function pushToSBMS(dataToSave) {
				null;
			}

			function saveFile(blob, filename) {
			    const link = document.createElement('a');
			    link.href = URL.createObjectURL(blob);
			    link.download = filename;
			    link.click();
			}

			function getScannedData() {
			    // Gather scanned data
			    return scannedCartons;
			}

			function convertToCSV(data) {
			    if (!data || !data.length) {
			        return '';
			    }

			    // Extract the headers
			    const headers = Object.keys(data[0]);

			    // Map data to CSV rows
			    const csvRows = data.map(row => {
			        return headers.map(field => {
			            const value = row[field] === null || row[field] === undefined ? '' : row[field];
			            return typeof value === 'string' && value.includes(',') ? `"${value}"` : value;
			        }).join(',');
			    });

			    // Combine headers and rows
			    return [headers.join(','), ...csvRows].join('\n');
			}

			function showItemDetails(itemCode,itemID,pendingQty,packSize) {
			    // Fetch valid cartons list for this item when the modal opens
			   
			    fetchValidCartons(itemID).then(validCartonsList => {
			       
			        // If valid cartons are not fetched, refuse from allowing to scan
			        if(!validCartonsList || validCartonsList.length < 1)
			        	return;

			        // Display the modal
			        const modal = document.getElementById('itemDetailsModal');
			        const modalContent = document.getElementById('modalContent');
			        
			        // Set the modal content with item details and scanning options
			        modalContent.innerHTML = `
			            <h2>Item Details for ${itemCode}</h2>
			            <p>Pending Quantity: <span id="pendingQty">${pendingQty}</span> PCS</p>
			            <p>Pending Cartons: <span id="pendingCartons">${calculatePendingCartons(pendingQty,packSize)}</span></p>
			            <div id="scanResults">
			                <h3>Scanned Cartons</h3>
			                <table id="scannedTable">
			                    <thead>
			                        <tr>
			                            <th>Carton Number</th>
			                            <th>Quantity (PCS)</th>
			                            <th>Scan Time</th>
			                        </tr>
			                    </thead>
			                    <tbody>
			                        <!-- Scanned cartons will be added here -->
			                    </tbody>
			                </table>
			            </div>
			            <div id="scanControls">
			                ${renderScanControls()}
			            </div>
			            <div class="progress">
			                <p>Scanned Cartons: <span id="scannedCount">0</span></p>
			                <progress id="scanProgress" value="0" max="${calculatePendingCartons(pendingQty,packSize)}"></progress>
			            </div>
			        `;

			        const retryButton = document.getElementById('retryButton');
			        if(retryButton){
			        	retryButton.addEventListener('click', () => {
					    	if (confirm('Do you want to restart scanning data?'))
					    		initScanner(itemCode, validCartonsList);
						});	
			        }

			        // Show the modal
					showModal();// modal.style.display = 'block';


			        // Initialize scanning based on the device type
			        initScanner(itemCode, validCartonsList);

			    });
			}

			// Function to handle save action confirmation
			function confirmSaveAction() {
			    if (confirm('Do you want to save the scanned data?')) {
			        // Show options to save
			        const saveOption = prompt('Choose an option:\n1. Save JSON\n2. Save CSV\n3. Push to SBMS');

			        switch (saveOption) {
			            case '1':
			                saveData('json');
			                break;
			            case '2':
			                saveData('csv');
			                break;
			            case '3':
			                pushToSBMS();
			                break;
			            default:
			                alert('Invalid option selected');
			                break;
			        }
			    }
			}


			// Utility function to determine if the device is mobile
			function isMobileDevice() {
			    return /Mobi|Android/i.test(navigator.userAgent);
			}

			async function hasCamera() {
			    if (navigator.mediaDevices && navigator.mediaDevices.enumerateDevices) {
			        try {
			            const devices = await navigator.mediaDevices.enumerateDevices();
			            return devices.some(device => device.kind === 'videoinput');
			        } catch (error) {
			            console.error('Error detecting camera:', error);
			        	alert('Error detecting camera:' + error.message);
			            return false;
			        }
			    } else {
			        // Fallback for browsers that don't support navigator.mediaDevices
			        console.warn('Camera detection not supported in this browser.');
			        alert('Camera detection not supported in this browser.');
			        return false;
			    }
			}

			// Function to fetch valid cartons list for the item
			async function fetchValidCartons(itemID) {
			    try {

			    	const email_id = '';
		            const username = '';
		            const password = '';
		            const unit_id = 7;
		            const data_type = 'VALID_CARTONS';
		            const search_param = itemID;
			        const response = await fetch(`${api_base_url}/SelectFromSBMS`, {
			            method: 'POST',
			            headers: {
			                'Content-Type': 'application/json'
			            },
			            body: JSON.stringify({username, password, unit_id, email_id, data_type, search_param})
			        });
			        const data = await response.json();
			        if(response.status = 200 && data.output.length > 0)
			        	return data.output;
			       	else
			       		alert('Error fetching valid cartons for ITEM:'+itemID);	
			    } catch (error) {
			        console.error('Error fetching valid cartons:', error);
			        // return [];
			        alert('Error fetching valid cartons for ITEM:'+itemID);
			    }
			}

			// Function to calculate pending cartons (placeholder)
			function calculatePendingCartons(pendingQty,packingSize) {
			    return Math.ceil(pendingQty / packingSize);
			}

			// Function to render scan controls based on device type
			function renderScanControls() {
				console.log('About to renderScanControls with CameraAvailable = ' + cameraAvailable);
			    if (cameraAvailable) {
			        return `
			            <p>Use your camera to scan QR codes continuously.</p>
			            <div id="cameraContainer">
			            	<button id="retryButton">Restart/Retry</button>
				            <video id="cameraFeed" autoplay playsinline></video>
	                		<canvas id="overlayCanvas"></canvas>
			                <canvas id="canvas" hidden></canvas>
	                	</div>
	                	<div id="controls">
							<button id="toggleScan">Pause</button>
						</div>
			        `;
			    } else {
			        return `
			            <p>Use your handheld scanner to scan QR codes.</p>
			            <input type="text" id="scannerInput" placeholder="Scan here..." style="width: 50%; margin: 0 auto;" autofocus>
			        `;
			    }
			}

			// Function to initialize scanning logic
			async function initScanner(itemCode, validCartonsList) {
			    const scanProgress = document.getElementById('scanProgress');
			    const scannedCount = document.getElementById('scannedCount');
			    const pendingQtyElement = document.getElementById('pendingQty');
			    const pendingCartonsElement = document.getElementById('pendingCartons');

			    scannedCartons = [];
			    document.getElementById("scannedTable").getElementsByTagName("tbody")[0].innerHTML = "";
                scannedCount.textContent = 0;
                scanProgress.value = 0;
				
				console.log('Starting ScannerMan with Camera Available = ' + cameraAvailable);
				scanner = new ScannerMan(cameraAvailable);
				scanner.startScanning(scanData => {
			        console.log("Scanned QR code:", scanData);
			        return processScanResult(scanData, itemCode, validCartonsList, scannedCartons, scanProgress, scannedCount, pendingQtyElement, pendingCartonsElement);
			    }).then(() => {
					console.log("Scan started successfully");
				});

			}

			// Function to process scanned data
            function processScanResult(scanData, itemCode, validCartonsList, scannedCartons, scanProgress, scannedCount, pendingQtyElement, pendingCartonsElement) {
            	try {
	                const parsedData = scanData.split(';');
	                const scannedItemCode = parsedData[0];
	                const uniqueCartonNumber = parsedData[1];
	                const quantityPCS = parseInt(parsedData[3], 10);

	                // Validate the scanned data
	                if (scannedItemCode !== itemCode)
	                	return 'Error: Scanned item code ('+scannedItemCode+') mismatch the selected item code ('+itemCode+').';

	                if (scannedCartons.length > 0 && scannedCartons.some(item => item.CartonNo === uniqueCartonNumber))
	                    return 'Error: Carton ('+uniqueCartonNumber+') is duplicate and already scanned.';
	               
	                if (!validCartonsList.some(item => item.PACK_SRL_NO === uniqueCartonNumber))
	                	return 'Error: Invalid carton number. Check detail for ' + uniqueCartonNumber;

	                // Add scanned carton to the list
	                const scanTime = new Date().toLocaleTimeString();
	                scanned_data = {"ProductCode":itemCode,"CartonNo":uniqueCartonNumber,"Qty":quantityPCS,"TimeStamp":scanTime};
	                scannedCartons.push(scanned_data);

	                //update the scan table rows to show new scan
	                updateScanTable(uniqueCartonNumber, quantityPCS, scanTime);
	                
	                // Update the progress bar and scanned count
	                v_scanned = scannedCartons.length;
	                scannedCount.textContent = v_scanned;
	                scanProgress.value = v_scanned;
	                
	                // Update pending quantities
	                let pendingQty = parseInt(pendingQtyElement.textContent, 10);
	                pendingQty -= quantityPCS;
	                pendingQtyElement.textContent = pendingQty;

	                // Update pending cartons
	                let pendingCartons = parseInt(pendingCartonsElement.textContent, 10);
	                pendingCartons -=1;
	                pendingCartonsElement.textContent = pendingCartons;

	                // Check if scanning is complete
	                if (pendingQty <= 0) {
	                    disableScanning();
	                    alert('Scanning complete.');
	                }

	                return '0';
			    } catch (error) {
			        console.error('Error processing scan result:', error);
			        return `Error: ${error.message}`;
			    }
            }

			// Function to update the scan table with the new scanned carton
			function updateScanTable(cartonNumber, quantityPCS, scanTime) {
			    const tableBody = document.getElementById('scannedTable').querySelector('tbody');
			    const row = document.createElement('tr');
			    row.innerHTML = `
			        <td>${cartonNumber}</td>
			        <td>${quantityPCS}</td>
			        <td>${scanTime}</td>
			    `;
			    tableBody.appendChild(row);
			}

			// Function to disable scanning once completed
			function disableScanning() {
			    if(scanner) scanner.stopCameraScan();
				const scannerInput = document.getElementById('scannerInput');
				if (scannerInput) scannerInput.disabled = true; // Disable input for handheld scanner
			}
			
			// Function to show the modal
			function showModal() {
			    const modal = document.getElementById('itemDetailsModal');
			    modal.style.display = 'block';
			}

			function closeModal() {
			    confirmSaveAction();
			    const modal = document.getElementById('itemDetailsModal');
			    modal.style.display = 'none';
                disableScanning();
			}

		</script>
	    <script src="tpac_library/js/buttons.dataTables.min.js" async></script>
	    <script src="tpac_library/js/jszip.min.js" async></script>
	    <script src="tpac_library/js/vfs_fonts.min.js" async></script>
	    <script src="tpac_library/js/buttons.print.min.js" async></script>
	    <script src="tpac_library/js/buttons.html5.min.js" async></script>
	</body>
</html>
