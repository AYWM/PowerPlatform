<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<title></title>
		<style type="text/css">
			#ordersTable {
			    width: 100%;
			    border-collapse: collapse;
			}

			#ordersTable th, #ordersTable td {
			    border: 1px solid #ddd;
			    padding: 8px;
			    text-align: left;
			}

			#ordersTable th {
			    background-color: #f2f2f2;
			}

			@media screen and (max-width: 600px) {
			    #ordersTable thead {
			        display: none;
			    }

			    #ordersTable, #ordersTable tbody, #ordersTable tr, #ordersTable td {
			        display: block;
			        width: 100%;
			    }

			    #ordersTable tr {
			        margin-bottom: 15px;
			    }

			    #ordersTable td {
			        text-align: right;
			        padding-left: 50%;
			        position: relative;
			    }

			    #ordersTable td::before {
			        content: attr(data-label);
			        position: absolute;
			        left: 0;
			        padding-left: 15px;
			        font-weight: bold;
			        text-align: left;
			    }
			}

			/* Modal container */
			.modal {
			    display: none; /* Hidden by default */
			    position: fixed; /* Stay in place */
			    z-index: 1; /* Sit on top */
			    left: 0;
			    top: 0;
			    width: 100%; /* Full width */
			    height: 100%; /* Full height */
			    overflow: auto; /* Enable scroll if needed */
			    background-color: rgb(0,0,0); /* Fallback color */
			    background-color: rgba(0,0,0,0.4); /* Black w/ opacity */
			    padding-top: 60px; /* Padding from the top */
			}

			/* Modal content */
			.modal-content {
			    background-color: #fefefe;
			    margin: 5% auto; /* 5% from the top and centered */
			    padding: 20px;
			    border: 1px solid #888;
			    width: 80%; /* Could be more or less, depending on screen size */
			    max-width: 900px; /* Maximum width for larger screens */
			    border-radius: 10px; /* Rounded corners */
			    box-shadow: 0 5px 15px rgba(0,0,0,0.3); /* Subtle shadow for depth */
			}

			/* Close button */
			.close {
			    position: absolute;
			    right: 25px;
			    top: 20px;
			    color: #aaa;
			    font-size: 28px;
			    font-weight: bold;
			    cursor: pointer;
			}

			.close:hover,
			.close:focus {
			    color: #000;
			    text-decoration: none;
			    cursor: pointer;
			}

			/* Table styling inside modal */
			#scannedTable {
			    width: 100%;
			    border-collapse: collapse;
			    margin-top: 20px;
			}

			#scannedTable th, #scannedTable td {
			    border: 1px solid #ddd;
			    padding: 8px;
			}

			#scannedTable th {
			    background-color: #f2f2f2;
			    text-align: left;
			}

			#scannedTable td {
			    text-align: center;
			}

			/* Progress bar */
			.progress {
			    margin-top: 20px;
			}

			progress {
			    width: 100%;
			    height: 20px;
			}

			/* Responsive video feed for camera scanning (mobile) */
            #cameraFeed {
                width: 100%;
                height: auto; /*240px;*/
                object-fit: cover;
                border: 2px solid #333; /*1px solid #ddd;*/
                border-radius: 5px;
                margin-top: 10px;
            }

            #cameraContainer {
		      position: relative;
		      width: 320px; /* Adjust as needed */
		      margin: auto;
		    }
		    #cameraFeed {
		      width: 100%;
		      height: auto;
		    }
		    #overlayCanvas {
		      position: absolute;
		      top: 0;
		      left: 0;
		      width: 100%;
		      height: 100%;
		      pointer-events: none; /* Allows clicks to pass through */
		    }
		    .rectangle {
		      border: 2px solid red;
		      position: absolute;
		      top: 20%;
		      left: 10%;
		      width: 80%;
		      height: 60%;
		    }
		    #controls {
		      text-align: center;
		      margin-top: 10px;
		    }
			
		</style>
		<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css" crossorigin="anonymous" />
	    <script src="tpac_library/js/jsQR.js"></script>
	    <meta name="viewport" content="width=device-width, initial-scale=1.0">
	    <link rel="stylesheet" href="tpac_library/css/dataTables.min.css">
	    <link rel="stylesheet" type="text/css" href="tpac_library/css/dataTables.buttons.min.css">
	    <link rel="stylesheet" type="text/css" href="tpac_library/css/responsive.dataTables.min.css">
	    <!-- <script id="TeamsJs" src="tpac_library/js/MicrosoftTeams.min.js" async></script> -->
	    <script src="tpac_library/js/pdfmake.min.js" async></script>
	    <script src="tpac_library/js/jquery-3.7.1.slim.min.js"></script>
	    <script src="tpac_library/js/dataTables.min.js"></script>
	    <script src="tpac_library/js/dataTables.responsive.min.js"></script>
	    <script src="tpac_library/js/dataTables.buttons.min.js"></script>


	</head>
	<body>
		<h1 id="detailsHeader"></h1>
		<h3 id="detailsSummary"></h3>

		<div id="itemDetailsModal" class="modal">
		    <div class="modal-content" id="modalContent">
		       
		        <!-- Dynamic content will be injected here by JavaScript -->
		        <div id="itemDetailsContent" style="display: none;">
		            <!-- Item details will be displayed here -->

		        </div>
		    </div>
		    <span class="close" id="closeModal">&times; CLOSE</span>
		</div>


		<table id="ordersTable">
		    <thead>
		        <tr>
		            <th>ITEM CODE</th>
		            <th>ITEM NAME</th>
		            <th>PACKING SIZE</th>
		            <th>LOCATION</th>
		            <th>SCHEDULED QTY</th>
		            <th>DISPATCHED QTY</th>
		            <th>PENDING QTY</th>
		        </tr>
		    </thead>
		    <tbody>
		        <!-- Rows will be added dynamically by JavaScript -->
		    </tbody>
		</table>

		<script type="text/javascript">
			
			// let api_base_url = 'http://192.168.12.14:3000/sbms';
			let api_base_url = 'https://192.168.12.18:3001/sbms';
        	// let api_base_url = 'https://api.tpacpackaging.com:3001/sbms';
	        // let detail_page_url = 'http://192.168.12.14:8888/DO_DETAIL.html';
	        let detail_page_url = 'https://aywm.github.io/PowerPlatform/SBMS/DO_DETAIL.html';
			let scannedCartons = [];
			let scanner,audioContext,errorBeepSound,correctBeepSound;

			document.addEventListener('DOMContentLoaded', function () {
			    const urlParams = new URLSearchParams(window.location.search);
			    const doNumber = urlParams.get('doNumber');
			    const unit_id = urlParams.get('unit_id');
			    const deliveryOrderId = urlParams.get('deliveryOrderId');
			   
			    document.getElementById('detailsHeader').innerText = `Showing Details for Delivery Order Number: ${doNumber}`;
			    fetchOrderDetails(unit_id,deliveryOrderId);

			    try{
		            // Initialize error beep sound
		            audioContext = new (window.AudioContext || window.webkitAudioContext)();
		            errorBeepSound = new Audio('tpac_library/audio/beep-05.mp3');
                    correctBeepSound = new Audio('tpac_library/audio/beep-02.mp3');
			    }catch(error) {
                    console.error("Error loading error beep sound:", error);
                }
			});

			// Close the modal when the user clicks on <span> (x)
			document.getElementById('closeModal').onclick = function() {
			    closeModal();
			}

			// Close the modal when the user clicks anywhere outside of the modal
			window.onclick = function(event) {
			    const modal = document.getElementById('itemDetailsModal');
			    if (event.target === modal) {
			        closeModal();
			    }
			}

			// Move this function outside of the CameraScanner class
            function debounce(func, wait) {
                let timeout;
                return function (...args) {
                    clearTimeout(timeout);
                    timeout = setTimeout(() => func.apply(this, args), wait);
                };
            }

			class CameraScanner {
                constructor() {
                    this.videoElement = null;
                    this.stream = null;
                    this.canvasElement = null;
                    this.ctx = null;
                    this.overlayCanvas = null;
                    this.overlayCtx = null;
                    this.scanIntervalId = null;
                    this.callback = null;
                    this.handlePlay = this.handlePlay.bind(this);
                    this.handlePause = this.handlePause.bind(this); 


		            // Accessing video element to display camera feed
		            this.videoElement = document.getElementById('cameraFeed');
		            this.overlayCanvas = document.getElementById('overlayCanvas');
        			this.isScanning = true;

        			//Set up event listeners
                    this.setupEventListeners();

                }

                async startCameraScan(callback) {

                    try {
                        
                        this.callback = callback;  // Store the callback function

                        if (!this.videoElement) {
                            throw new Error('Video element not found.');
                        }

                        if (!this.overlayCanvas) {
                            throw new Error('Overlay canvas element not found.');
                        }
                        
                        // Request camera access
                        this.stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } });
                        this.videoElement.srcObject = this.stream;
                        // this.videoElement.play();



                        // Create a canvas to capture frames from the video feed
                        this.canvasElement = document.createElement('canvas');
                        this.ctx = this.canvasElement.getContext('2d');

                        if (!this.ctx) {
                            throw new Error('Canvas 2D context not found.');
                        }

                        // Create overlay canvas for the fixed rectangle
                        this.overlayCtx = this.overlayCanvas.getContext('2d');

                        

                        // Return a promise that resolves when the scan starts
                        return new Promise(resolve => {
                            resolve();
                        });
                    } catch (error) {
                        console.error("Error starting camera scan:", error);
                        alert('Camera access denied. Please allow camera access and click Retry.');
                    }
                }

                setupEventListeners() {

                	this.videoElement.addEventListener('play', this.handlePlay);
                    this.videoElement.addEventListener('pause', this.handlePause);

			        document.getElementById('toggleScan').addEventListener('click', () => {
					if (this.isScanning) {
						this.handlePause();
						document.getElementById('toggleScan').textContent = 'Resume';
					} else {
						this.handlePlay();
						document.getElementById('toggleScan').textContent = 'Pause';
					}
						this.isScanning = !this.isScanning;	
					});
			    }

                handlePlay() {
                    // Update canvas dimensions when video starts playing
                    this.updateCanvasDimensions();
                    this.drawFixedRectangle();
                    if (this.callback) {
                        this.startScanning(this.callback); // Ensure callback is passed
                    }
                }

                handlePause() {
                    // Stop scanning when video pauses
                    this.stopScanning();
                }

                updateCanvasDimensions() {
                    if (this.canvasElement && this.videoElement) {
                        this.canvasElement.width = this.videoElement.videoWidth;
                        this.canvasElement.height = this.videoElement.videoHeight;
                        this.overlayCanvas.width = this.videoElement.videoWidth;
                        this.overlayCanvas.height = this.videoElement.videoHeight;
                    } else {
                        console.error('Canvas or video element not properly initialized.');
                    }
                }

				drawFixedRectangle() {
					if (this.overlayCtx) {
						const width = this.overlayCanvas.width;
						const height = this.overlayCanvas.height;

						this.overlayCtx.clearRect(0, 0, width, height);
						this.overlayCtx.strokeStyle = 'red'; //'rgba(255, 0, 0, 0.5)'
						this.overlayCtx.lineWidth = 2;
						// this.overlayCtx.strokeRect(50, 50, this.canvasElement.width - 100, this.canvasElement.height - 100);
						this.overlayCtx.strokeRect(width * 0.1, height * 0.2, width * 0.8, height * 0.6);
					} else {
                        console.error('Overlay canvas context not found.');
                    }
				}

                drawLine(begin, end, color) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(begin.x, begin.y);
                    this.ctx.lineTo(end.x, end.y);
                    this.ctx.lineWidth = 4;
                    this.ctx.strokeStyle = color;
                    this.ctx.stroke();
                }

                // Method to draw a box around the QR code
                drawBoxAroundQRCode(location) {
                    this.drawLine(location.topLeftCorner, location.topRightCorner, "#FF3B58");
                    this.drawLine(location.topRightCorner, location.bottomRightCorner, "#FF3B58");
                    this.drawLine(location.bottomRightCorner, location.bottomLeftCorner, "#FF3B58");
                    this.drawLine(location.bottomLeftCorner, location.topLeftCorner, "#FF3B58");
                }

                startScanning(callback) {

                    if (!callback) {
                        console.error('Callback function is not provided.');
                        return;
                    }

                    let lastScanTime = 0;
                    const scanInterval = 963; // Delay in milliseconds

                    const scan = () => {
                        const now = Date.now();
                        if (now - lastScanTime < scanInterval) {
                            // Skip scanning if within the delay interval
                            requestAnimationFrame(scan);
                            return;
                        }
						
						this.overlayCtx.clearRect(0, 0, this.overlayCanvas.width, this.overlayCanvas.height);
						this.drawFixedRectangle();
                        
                        this.ctx.drawImage(this.videoElement, 0, 0, this.canvasElement.width, this.canvasElement.height);

                        const imageData = this.ctx.getImageData(0, 0, this.canvasElement.width, this.canvasElement.height);
                        const qrCode = jsQR(    
                                            imageData.data,
                                            imageData.width,
                                            imageData.height,
                                            // {inversionAttempts: "dontInvert",}
                                        );

                        if (qrCode) {
                            console.log(qrCode.data);

                            try {
                                callback(qrCode.data);
                            } catch (error) {
                                console.log('Callback error:', error);
                            }

                            // Draw a box around the QR code
                            // this.drawBoxAroundQRCode(qrCode.location);

                            // Update last scan time
                            lastScanTime =  Date.now();
                        }

                        // Continue scanning
                        requestAnimationFrame(scan);
                    };

                    // Start the scanning process
                    requestAnimationFrame(scan);
                }

                stopScanning() {
                    clearInterval(this.scanIntervalId);
                    this.scanIntervalId = null;
                    this.stream.getTracks().forEach(track => track.stop());
                    this.videoElement.srcObject = null;
                }

                async stopCameraScan() {
                    try {
                        // Stop the video stream
                        this.stream.getTracks().forEach(track => track.stop());

                        // Remove video element from the DOM
                        this.videoElement.pause();
                        this.videoElement.srcObject = null;
                        this.videoElement.remove();

                        // Clean up event listeners
                        this.videoElement.removeEventListener('play', this.handlePlay);
                        this.videoElement.removeEventListener('pause', this.handlePause);

                        // Remove other resources
                        this.canvasElement.remove();

                        console.log("Camera scan stopped successfully");
                    } catch (error) {
                        console.error("Error stopping camera scan:", error);
                    }
                }

            }


            async function fetchOrderDetails(p_unit_id,p_deliveryOrderId) {
                try {
                    const email_id = '';
                    const username = '';
                    const password = '';
                    const unit_id = p_unit_id;
                    const data_type = 'PENDING_DO';
                    const search_param = p_deliveryOrderId;
                    const response = await fetch(`${api_base_url}/SelectFromSBMS`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({username, password, unit_id, email_id, data_type, search_param})
                    });
                    const data = await response.json();
                    displayOrderDetails(data.output);
                } catch (error) {
                    console.error('Error fetching pending orders:', error);
                }
            }


			function displayOrderDetails(orders) {
			    const tableBody = document.getElementById('ordersTable').querySelector('tbody');
			    tableBody.innerHTML = ''; // Clear any existing rows

			    let totalItems = 0;
			    let totalScheduledQty = 0;
			    let totalDispatchedQty = 0;
			    let totalPendingQty = 0;
			    

			    orders.forEach(detail => {
			        const row = document.createElement('tr');
			        console.log(detail);
			        // Update the totals
			        totalItems += 1;
			        totalScheduledQty += detail.SCHEDULED_QTY;
			        totalDispatchedQty += detail.DISPATCHED_QTY;
			        totalPendingQty += detail.PENDING_QTY;

			        // Creating table cells
			        row.innerHTML = `
			            <td data-label="ITEM CODE">
			                <a href="#" onclick="showItemDetails('${detail.ITEM_CODE}','${detail.ITEM_ID}',${detail.PENDING_QTY},${detail.PACKING_SIZE})">
			                    <i class="fas fa-info-circle"></i> ${detail.ITEM_CODE}
			                </a>
			            </td>
			            <td data-label="ITEM NAME">${detail.ITEM_NAME}</td>
			            <td data-label="PACKING SIZE">${detail.PACKING_SIZE}</td>
			            <td data-label="LOCATION">${detail.LOCATION}</td>
			            <td data-label="SCHEDULED QTY">
			                ${detail.SCHEDULED_QTY.toLocaleString(undefined, {
			                    minimumFractionDigits: 2,
			                    maximumFractionDigits: 7
			                })}
			            </td>
			            <td data-label="DISPATCHED QTY">
			                ${detail.DISPATCHED_QTY.toLocaleString(undefined, {
			                    minimumFractionDigits: 2,
			                    maximumFractionDigits: 7
			                })}
			            </td>
			            <td data-label="PENDING QTY">
			                ${detail.PENDING_QTY.toLocaleString(undefined, {
			                    minimumFractionDigits: 2,
			                    maximumFractionDigits: 7
			                })}
			            </td>
			        `;
			        tableBody.appendChild(row);
			    });

			    // Display the totals
			    let text_summary = '';
			    text_summary =`Total Items: ${totalItems}`;
			    text_summary = text_summary + ', Total Scheduled: ' + totalScheduledQty.toLocaleString(undefined, {
			        minimumFractionDigits: 2,
			        maximumFractionDigits: 7
			    });
			    text_summary = text_summary + ', Total Dispatched: ' + totalDispatchedQty.toLocaleString(undefined, {
			        minimumFractionDigits: 2,
			        maximumFractionDigits: 7
			    });
			    text_summary = text_summary + ', Total Pending: ' + totalPendingQty.toLocaleString(undefined, {
			        minimumFractionDigits: 2,
			        maximumFractionDigits: 7
			    });

			    document.getElementById('detailsSummary').textContent = text_summary;

			    new DataTable('#ordersTable'
                        ,{
                            // responsive: true,
                            buttons: [  'copy', 'csv',  'excel', 'print'
                                        ,{
                                            extend: 'pdfHtml5',
                                            orientation: 'landscape',
                                            // pageSize: search_param === 'ALL' ? 'A2' : 'A4'
                                        }
                                    ],
                            layout: {
                                top2Start: 'buttons'
                            },
                            fixedColumns: true,
                            "searching": true,
                            "ordering": true,
                            "info": true,
                            "lengthChange": true,
                            "lengthMenu": [[25, 50, 75, -1], [25, 50, 75, "All"]],
                            "striped": true,
                            "hover": true
                        }
                );
			}

			// Function to save data in JSON or CSV format
			function saveData(format) {

			    dataToSave = getScannedData();

			    if (format === 'json') {
			        const blob = new Blob([JSON.stringify(dataToSave)], { type: 'application/json' });
			        saveFile(blob, 'scanned_data.json');
			    } else if (format === 'csv') {
			        const csvData = convertToCSV(dataToSave);
			        const blob = new Blob([csvData], { type: 'text/csv' });
			        saveFile(blob, 'scanned_data.csv');
			    }
			    
			    pushToSBMS(dataToSave);
			}

			// Function to push data to SBMS
			function pushToSBMS(dataToSave) {
				null;
			}

			function saveFile(blob, filename) {
			    const link = document.createElement('a');
			    link.href = URL.createObjectURL(blob);
			    link.download = filename;
			    link.click();
			}

			function getScannedData() {
			    // Gather scanned data
			    return scannedCartons;
			}

			function convertToCSV(data) {
			    if (!data || !data.length) {
			        return '';
			    }

			    // Extract the headers
			    const headers = Object.keys(data[0]);

			    // Map data to CSV rows
			    const csvRows = data.map(row => {
			        return headers.map(field => {
			            const value = row[field] === null || row[field] === undefined ? '' : row[field];
			            return typeof value === 'string' && value.includes(',') ? `"${value}"` : value;
			        }).join(',');
			    });

			    // Combine headers and rows
			    return [headers.join(','), ...csvRows].join('\n');
			}

			function showItemDetails(itemCode,itemID,pendingQty,packSize) {
			    // Fetch valid cartons list for this item when the modal opens
			   
			    fetchValidCartons(itemID).then(validCartonsList => {
			       
			        // If valid cartons are not fetched, refuse from allowing to scan
			        if(!validCartonsList || validCartonsList.length < 1)
			        	return;

			        // Display the modal
			        const modal = document.getElementById('itemDetailsModal');
			        const modalContent = document.getElementById('modalContent');
			        
			        // Set the modal content with item details and scanning options
			        modalContent.innerHTML = `
			            <h2>Item Details for ${itemCode}</h2>
			            <p>Pending Quantity: <span id="pendingQty">${pendingQty}</span> PCS</p>
			            <p>Pending Cartons: <span id="pendingCartons">${calculatePendingCartons(pendingQty,packSize)}</span></p>
			            <div id="scanResults">
			                <h3>Scanned Cartons</h3>
			                <table id="scannedTable">
			                    <thead>
			                        <tr>
			                            <th>Carton Number</th>
			                            <th>Quantity (PCS)</th>
			                            <th>Scan Time</th>
			                        </tr>
			                    </thead>
			                    <tbody>
			                        <!-- Scanned cartons will be added here -->
			                    </tbody>
			                </table>
			            </div>
			            <div id="scanControls">
			                ${renderScanControls(isMobileDevice())}
			            </div>
			            <div class="progress">
			                <p>Scanned Cartons: <span id="scannedCount">0</span></p>
			                <progress id="scanProgress" value="0" max="${calculatePendingCartons(pendingQty,packSize)}"></progress>
			            </div>
			        `;

			        // Initialize scanning based on the device type
			        initScanner(itemCode, validCartonsList);

			        const retryButton = document.getElementById('retryButton');
			        if(retryButton){
			        	retryButton.addEventListener('click', () => {
					    	if (confirm('Do you want to restart scanning data?'))
					    		initScanner(itemCode, validCartonsList);
						});	
			        }

			        // Show the modal
					showModal();// modal.style.display = 'block';
			    });
			}

			// Function to handle save action confirmation
			function confirmSaveAction() {
			    if (confirm('Do you want to save the scanned data?')) {
			        // Show options to save
			        const saveOption = prompt('Choose an option:\n1. Save JSON\n2. Save CSV\n3. Push to SBMS');

			        switch (saveOption) {
			            case '1':
			                saveData('json');
			                break;
			            case '2':
			                saveData('csv');
			                break;
			            case '3':
			                pushToSBMS();
			                break;
			            default:
			                alert('Invalid option selected');
			                break;
			        }
			    }
			}


			// Utility function to determine if the device is mobile
			function isMobileDevice() {
			    return /Mobi|Android/i.test(navigator.userAgent);
			}

			// Function to fetch valid cartons list for the item
			async function fetchValidCartons(itemID) {
			    try {

			    	const email_id = '';
		            const username = '';
		            const password = '';
		            const unit_id = 7;
		            const data_type = 'VALID_CARTONS';
		            const search_param = itemID;
			        const response = await fetch(`${api_base_url}/SelectFromSBMS`, {
			            method: 'POST',
			            headers: {
			                'Content-Type': 'application/json'
			            },
			            body: JSON.stringify({username, password, unit_id, email_id, data_type, search_param})
			        });
			        const data = await response.json();
			        if(response.status = 200 && data.output.length > 0)
			        	return data.output;
			       	else
			       		alert('Error fetching valid cartons for ITEM:'+itemID);	
			    } catch (error) {
			        console.error('Error fetching valid cartons:', error);
			        // return [];
			        alert('Error fetching valid cartons for ITEM:'+itemID);
			    }
			}

			// Function to calculate pending cartons (placeholder)
			function calculatePendingCartons(pendingQty,packingSize) {
			    return Math.ceil(pendingQty / packingSize);
			}

			// Function to render scan controls based on device type
			function renderScanControls(isMobile) {
			    if (isMobile) {
			        return `
			            <p>Use your camera to scan QR codes continuously.</p>
			            <div id="cameraContainer">
			            	<button id="retryButton">Restart/Retry</button>
				            <video id="cameraFeed" autoplay playsinline></video>
	                		<canvas id="overlayCanvas"></canvas>
			                <canvas id="canvas" hidden></canvas>
	                	</div>
	                	<div id="controls">
							<button id="toggleScan">Pause</button>
						</div>
			        `;
			    } else {
			        return `
			            <p>Use your handheld scanner to scan QR codes.</p>
			            <input type="text" id="scannerInput" placeholder="Scan here..." style="width: 50%; margin: 0 auto;" autofocus>
			        `;
			    }
			}

			// Function to initialize scanning logic
			async function initScanner(itemCode, validCartonsList) {
			    const scanProgress = document.getElementById('scanProgress');
			    const scannedCount = document.getElementById('scannedCount');
			    const pendingQtyElement = document.getElementById('pendingQty');
			    const pendingCartonsElement = document.getElementById('pendingCartons');

			    scannedCartons = [];
			    document.getElementById("scannedTable").getElementsByTagName("tbody")[0].innerHTML = "";
                scannedCount.textContent = 0;
                scanProgress.value = 0;

			    if (isMobileDevice()) {

			    	scanner = new CameraScanner();
					// Ensure the video element is visible
        			document.getElementById('cameraFeed').style.display = 'block';
					
					try {
						await scanner.startCameraScan(scanData => {
							console.log("Scanned QR code:", scanData);
							processScanResult(scanData, itemCode, validCartonsList, scannedCartons, scanProgress, scannedCount, pendingQtyElement, pendingCartonsElement);
						}).then(() => {
							console.log("Scan started successfully");
						});
					} catch (error) {
				        console.error("Error starting camera scan:", error);
				        alert('Camera access denied. Please allow camera access and click Retry.');
				    }

			    } else {

			        document.getElementById('scannerInput').addEventListener('keypress', function (e) {
			            if (e.key === 'Enter') {
			                processScanResult(e.target.value.trim(), itemCode, validCartonsList, scannedCartons, scanProgress, scannedCount, pendingQtyElement, pendingCartonsElement);
			                e.target.value = ''; // Clear input
			            }
			        });
			    }
			}

			// Function to process scanned data
            function processScanResult(scanData, itemCode, validCartonsList, scannedCartons, scanProgress, scannedCount, pendingQtyElement, pendingCartonsElement) {
                const parsedData = scanData.split(';');
                const scannedItemCode = parsedData[0];
                const uniqueCartonNumber = parsedData[1];
                const quantityPCS = parseInt(parsedData[3], 10);

                // Validate the scanned data
                if (scannedItemCode !== itemCode) {
                    // Play beep sound
                    if(errorBeepSound)
                        errorBeepSound.play();
                    alert('Scanned item code ('+scannedItemCode+') does not match the selected item code ('+itemCode+').');
                    return;
                }

                if (scannedCartons.length > 0 && scannedCartons.some(item => item.CartonNo === uniqueCartonNumber)) {
                    // Play beep sound
                    if(errorBeepSound)
                        errorBeepSound.play();
                      alert('Carton ('+uniqueCartonNumber+') is duplicate and already scanned.');
                      return;
                }
               
                if (!validCartonsList.some(item => item.PACK_SRL_NO === uniqueCartonNumber)) {
                    // Play beep sound
                    if(errorBeepSound)
                        errorBeepSound.play();
                    alert('Invalid carton number. Check detail for ' + uniqueCartonNumber);
                    return;
                }

                // Add scanned carton to the list
                const scanTime = new Date().toLocaleTimeString();
                scanned_data = {"ProductCode":itemCode,"CartonNo":uniqueCartonNumber,"Qty":quantityPCS,"TimeStamp":scanTime};
                scannedCartons.push(scanned_data);
                updateScanTable(uniqueCartonNumber, quantityPCS, scanTime);
                // Play beep sound
                if(correctBeepSound)
                    correctBeepSound.play();
                console.log(scannedCartons);
                
                // Update progress
                scannedCount.textContent = scannedCartons.length;
                scanProgress.value = scannedCartons.length;
                
                // Update pending quantities
                let pendingQty = parseInt(pendingQtyElement.textContent, 10);
                pendingQty -= quantityPCS;
                pendingQtyElement.textContent = pendingQty;

                // Update pending cartons
                let pendingCartons = parseInt(pendingCartonsElement.textContent, 10);
                pendingCartons -=1;
                pendingCartonsElement.textContent = pendingCartons;

                // Check if scanning is complete
                if (pendingQty <= 0) {
                    alert('Scanning complete.');
                    disableScanning();
                }
            }

			// Function to update the scan table with the new scanned carton
			function updateScanTable(cartonNumber, quantityPCS, scanTime) {
			    const tableBody = document.getElementById('scannedTable').querySelector('tbody');
			    const row = document.createElement('tr');
			    row.innerHTML = `
			        <td>${cartonNumber}</td>
			        <td>${quantityPCS}</td>
			        <td>${scanTime}</td>
			    `;
			    tableBody.appendChild(row);
			}

			// Function to disable scanning once completed
			function disableScanning() {
			    document.getElementById('scannerInput').disabled = true; // Disable input for handheld scanner
			    // Implement additional logic to stop camera feed if using mobile
			}

			
			// Function to show the modal
			function showModal() {
			    const modal = document.getElementById('itemDetailsModal');
			    modal.style.display = 'block';
			}

			function closeModal() {
			    confirmSaveAction();
			    const modal = document.getElementById('itemDetailsModal');
			    modal.style.display = 'none';
			    scanner.stopCameraScan();
                disableScanning();
			}

		</script>
	    <script src="tpac_library/js/buttons.dataTables.min.js" async></script>
	    <script src="tpac_library/js/jszip.min.js" async></script>
	    <script src="tpac_library/js/vfs_fonts.min.js" async></script>
	    <script src="tpac_library/js/buttons.print.min.js" async></script>
	    <script src="tpac_library/js/buttons.html5.min.js" async></script>
	</body>
</html>
